https://github.com/Toxicfireball/JLXNationalturningpoint.gi


#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, in4,    potentialmeter, sensorPotentiometer)
#pragma config(Sensor, in5,    linetracker1,   sensorLineFollower)
#pragma config(Sensor, in6,    linetracker2,   sensorLineFollower)
#pragma config(Sensor, dgtl1,  quadencoder1,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  quadencoder2,   sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  solenoid,       sensorDigitalOut)
#pragma config(Motor,  port1,           intake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftfront,     tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           leftback,      tmotorVex393HighSpeed_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           arm,           tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port5,           cat3,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           cat,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           cat2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightfront,    tmotorVex393HighSpeed_MC29, openLoop, driveLeft)
#pragma config(Motor,  port9,           rightback,     tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port10,          intake2,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//Only this file was saved before the school's toughbook factory reset for some reason
//Prob my last RobotC code :( moving to VCS which is cancer
//analog port 1 spoil
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"
#pragma DebuggerWindows("vexCompetitionControl")
float cmToTicks(float distance)
{
	float cm;
	//1 round=360 ticks
	//wheel circumference= 10.16cm*pi=31.09=360 ticks

	cm=distance*10.4775;
	return cm;
}
float degreetodistance (float distance)
{
	resetSensor(gyro);
	float degree;
	//1 degree=10 gyro value
	degree=distance*6.5;


	return degree;
}
//reading is in ticks-- 627.2tick/revolution
//one turn of wheels --4 inch wheels= 627.2*1ticks
//1 turn of each wheel 4*pi inches
//4*pi inches= 627.2*2 ticks

//ticks/inch=627.2*2/(4*pi)=99.82198
//for onni wheels 99.82198(encoder distance)=1 inch
//while my error is 30
//the actual error in inches - 0.3
float inchtoticks (float inch)
{
	float ticks;
	ticks=inch*26.61919474859647;
	return ticks;
}

void advFwdmk1 (int dist, int rev, int speed,)
{
	resetSensor(quadencoder1);
	resetSensor(quadencoder2);

	float error;
	float target;
	target= cmToTicks(dist);
	error= target-SensorValue[quadencoder1];



	while (error>0)
	{
		setMotor(rightback,speed);
		setMotor(rightfront,speed);
		setMotor(leftback,speed);
		setMotor(leftfront,speed);

		error= target-SensorValue[quadencoder1];
	}
	while(error<target/6.8&&error>0)
	{
		setMotor(rightback,rev);
		setMotor(rightfront,rev);
		setMotor(leftback,rev);
		setMotor(leftfront,rev);
		error=target-SensorValue[quadencoder1];

	}

	while (error<0)
	{
		setMotor(rightback,-rev);
		setMotor(rightfront,-rev);
		setMotor(leftback,-rev);
		setMotor(leftfront,-rev);
		error= target-SensorValue[quadencoder1];
		;
	}

	setMotor(rightback,0);
	setMotor(rightfront,0);
	setMotor(leftback,0);
	setMotor(leftfront,0);



}
void advTurnleft(int left,int rev,int speed)
{
	resetSensor(gyro);
	float error;
	float target;
	error= target+SensorValue[gyro];
	target= degreetodistance(left);

	while (error>0)
	{
		setMotor(rightback,speed);
		setMotor(rightfront,speed);
		setMotor(leftback,-speed);
		setMotor(leftfront,-speed);


		error= target+SensorValue[gyro];
	}
	while(error<target/9&&error>0)
	{
		setMotor(rightback,rev);
		setMotor(rightfront,rev);
		setMotor(leftback,-rev);
		setMotor(leftfront,-rev);
		error= target+SensorValue[gyro];

	}
//Unable to fix this code that break logic flow when used in conjuntion with other functions,despite changing float to int, use PID or standard encoder
	//	while (error<0)
	//	{
	//	setMotor(rightback,-rev);
	//	setMotor(rightfront,-rev);
	//setMotor(leftback,rev);
	//	setMotor(leftfront,rev);
	//	error= target+SensorValue[gyro];
	//	}
	if(error==0||SensorValue[gyro]==error)
	{
		setMotor(rightback,0);
		setMotor(rightfront,0);
		setMotor(leftback,0);
		setMotor(leftfront,0);
	}
}
void advRev(int dist,int cor,int speed)
{
	float error;
	float target;
	error= target+SensorValue[quadencoder1];
	target= cmToTicks(dist);
	resetSensor(quadencoder1);


	while (error>0)
	{
		setMotor(rightback,-speed);
		setMotor(rightfront,-speed);
		setMotor(leftback,-speed);
		setMotor(leftfront,-speed);

		error= target+SensorValue[quadencoder1];
	}
	while(error<target/5.5&&error>0)
	{
		setMotor(rightback,-cor);
		setMotor(rightfront,-cor);
		setMotor(leftback,-cor);
		setMotor(leftfront,-cor);
		error= target+SensorValue[quadencoder1];

	}

	while (error<0)
	{
		setMotor(rightback,cor);
		setMotor(rightfront,cor);
		setMotor(leftback,cor);
		setMotor(leftfront,cor);
		error= target+SensorValue[quadencoder1];
	}
	if(error==0||SensorValue[quadencoder1]==error)
	{
		setMotor(rightback,-cor);
		setMotor(rightfront,-cor);
		setMotor(leftback,-cor);
		setMotor(leftfront,-cor);
		sleep(700);
		stopAllMotors();

	}
}

void advturnRight(int right, int rev,int speed)
{
	resetSensor(gyro);
	int error;
	int target;
	error= target-SensorValue[gyro];
	target= degreetodistance(right);

	while (error>0)
	{
		setMotor(rightback,-speed);
		setMotor(rightfront,-speed);
		setMotor(leftback,speed);
		setMotor(leftfront,speed);

		error= target-SensorValue[gyro];
	}
	while(error<target/6.8&&error>0)
	{
		setMotor(rightback,-rev);
		setMotor(rightfront,-rev);
		setMotor(leftback,rev);
		setMotor(leftfront,rev);
		error= target-SensorValue[gyro];

	}

	//	while (error<0)
	//	{
	//	setMotor(rightback,rev);
	//	setMotor(rightfront,rev);
	//	setMotor(leftback,-rev);
	//	setMotor(leftfront,-rev);
	//	error= target-SensorValue[gyro];
	//	}
	if(error==0||SensorValue[quadencoder1]==error)
	{
		stopAllMotors();

	}

}
void movebase (float speed)
{
	setMotor(rightback,speed);
	setMotor(rightfront,speed);
	setMotor(leftback,speed);
	setMotor(leftfront,speed);
}


void linespotter (int speed)
{
	while (SensorValue[linetracker1]>2930)
	{
		movebase(speed);

	}
	while(SensorValue[linetracker1]<2930)
	{

		movebase(0);
		sleep(1000);
	}
}




int fixtimervalue(float rawseconds)
{
	float millisec;
	millisec=rawseconds*100;
	if(millisec<250)
	{
		millisec=250;
	}
	return millisec;
}




//kp=proportion( the fine tuning part)

void Pidbasecontrol(int target, float waittime, float maxpw, int speedlimit)
{
	resetSensor(quadencoder1);
	resetSensor(quadencoder2);
	//
	float Kp=0.2;
	float Ki=0.02;
	float Kd=0.5;
	//

	int error;
	float proportion;
	int integralraw;
	float integral;
	float lasterror;
	float derivative;
	float integralactive=inchtoticks(3);//_distance_//
	float integrallimit= speedlimit; //(this is speed limit)

	SensorValue[quadencoder1]=0;
	SensorValue[quadencoder2]=0;
	float finalpower;
	bool timerbool=true;
	clearTimer(T1);

	while(time1[T1]< fixtimervalue(waittime))
	{
		//error=target- current value
		error= inchtoticks(target)-SensorValue[quadencoder1];

		proportion=Kp*error;
		if (abs(error)< integralactive && error!=0)
		{
			integralraw=integralraw+error;
		}
		else
		{
			integralraw=0;
		}
		if(integralraw> integrallimit)
		{
			integralraw=integrallimit;
		}
		if (integralraw<- integrallimit)
		{
			integralraw=-integrallimit;
		}

		integral= Ki*integralraw; //if integralraw too big and we want to set the intlimit to the intraw do: Ki*(_value_/Ki)
		//if there is an error eg 10 you add 10 to the integralraw then keep adding the errors with the loops

		derivative= Kd*(error- lasterror);
		lasterror=error;

		if (error == 0)
		{
			derivative=0;
		}
		finalpower= proportion+integral+derivative; //proportion+derivative+integral

		if (finalpower>maxpw*127)
		{
			finalpower=maxpw*127;
		}
		else if(finalpower<-maxpw*127)
		{
			finalpower=-maxpw*127;
		}

		movebase(finalpower);
		wait1Msec(40);
		if (error<30)
		{
			timerbool=false;
		}
		if(timerbool)
		{
			clearTimer(T1);
		}
	}
	movebase(0);
}
void roller(float time,float speed)
{
	{
		clearTimer(T1);
		while(time1[T1]<time)
		{
			setMotor(intake,-speed);
			setMotor(intake2,-speed);
		}
		while(time1[T1]>=time)
		{
			setMotor(intake,0);
			setMotor(intake2,0);
			break;
		}
	}
}
void shoot( int time, int power)
{


	setMotor(cat,power);
	setMotor(cat2,-power);
	setMotor(cat3,power);
	sleep(time);

	setMotor(cat,0);
	setMotor(cat2,0);
	setMotor(cat3,0);

}



void neumaticsflip(float time, float speed,float fwd)

{
	clearTimer(T1);
	while(time1[T1]<time)
	{
		SensorValue(solenoid)=1;
		wait(0.3);
		movebase(fwd);
	}
	while(time1[T1]>=time)
	{

		stopAllMotors();
		SensorValue(solenoid)=0;
	}


}
void turnleftmk2(float left, int speed)
{
	resetSensor(gyro);
	while(SensorValue(gyro)>-left)
	{
		setMotor(rightback,speed);
		setMotor(rightfront,speed);
		setMotor(leftback,-speed);
		setMotor(leftfront,-speed);

	}
	setMotor(rightback,-9);
	setMotor(rightfront,-9);
	setMotor(leftback,9);
	setMotor(leftfront,9);
	wait(0.08);
	setMotor(rightback,0);
	setMotor(rightfront,0);
	setMotor(leftback,0);
	setMotor(leftfront,0);

}
void rollerflipmk3(int speed,int rollerspeed,int rollerfwd, int fwd, int rev)
{
	setMotor(intake,rollerspeed);
	setMotor(intake,rollerspeed);
	sleep(400);
	setMotor(intake,rollerspeed);
	setMotor(intake,rollerspeed);
	movebase(speed);
	sleep(rollerfwd);
	stopAllMotors();
	sleep(0.9);
	setMotor(intake,0);
	setMotor(intake,0);
	movebase(speed);
	sleep(fwd);


}
void timerfwdmk2(int time, int speed)
{
	movebase(speed);
	sleep(time);
	movebase(-10);
	sleep(20);
}
void ramball(float fwd,float speed,float push)
{
	clearTimer(T4);
	while(time1[T4]<fwd)
	{
		SensorValue[solenoid]=1;
	}
	while(time1[T4]<5)
	{
		movebase(50);
	}
	while(time1[T4]<push)
	{
		SensorValue[solenoid]=0;
		setMotor(rightback,-speed);
		setMotor(rightfront,-speed);
		setMotor(leftback,-speed);
		setMotor(leftfront,-speed);
		setMotor(intake,90);

		roller(400,100);

	}
}
void fwd( int target, int speed)
{
	resetSensor(quadencoder1);
	while(SensorValue(quadencoder1)<target)
	{
		movebase(speed);
	}
	movebase(speed/7);
	sleep(70);
	movebase(0);
}
void rollerflipmk4(int speed,int target, int rollspd)
{
	resetSensor(quadencoder1);
	while(SensorValue(quadencoder1)<target)
	{
		movebase(speed);
		setMotor(intake,rollspd);
		setMotor(intake2,rollspd);

	}
	movebase(speed/7);
	sleep(70);
	stopAllMotors();
}

void grabundercap(float grab,float speed,float grab2)
{
	clearTimer(T2);
	while(time1[T2]<grab)
	{
		movebase(speed);
	}
	while(time1[T2]<grab2)
	{
		movebase(speed);
		setMotor(intake,110);
		setMotor(intake2,110);
	}
	stopAllMotors();
}
void reset(float speed,float time,float st)
{
	clearTimer(T3);
	while(time1[T3]<time)
	{
		movebase(-speed);
	}
	while(time1[T3]>=time)
	{
		movebase(st);
		break;
	}
}
void timerfwd(float speed,float time,float st)
{
	clearTimer(T3);
	while(time1[T3]<time)
	{
		movebase(speed);
	}
	while(time1[T3]>=time)
	{
		movebase(st);
	}
}
void rollerflip(float roll, float roll2,float speed,int rollspd)
{
	{
		clearTimer(T4);
		while(time1[T4]<=roll)
		{
			roller(roll,rollspd);
			movebase(speed)

		}
		while(time1[T4]<=roll2)
		{

			roller(roll2,-rollspd);

			break;

		}
		stopAllMotors();
	}


}
void jam(int time, int speed)
{

	setMotor(leftfront,speed);
	setMotor(leftback,-speed);
	setMotor(rightfront,speed);
	setMotor(rightback,-speed);
	sleep(time);
	stopAllMotors();

}
void turnrightmk2(float right, int speed)
{
	resetSensor(gyro);
	while(SensorValue(gyro)<right)
	{
		setMotor(rightback,-speed);
		setMotor(rightfront,-speed);
		setMotor(leftback,speed);
		setMotor(leftfront,speed);
	}
	setMotor(rightback,7);
	setMotor(rightfront,7);
	setMotor(leftback,-7);
	setMotor(leftfront,-7);
	sleep(10);

}
void resetmk2(float time,float time2, float speed)
{

	movebase(-speed);

	sleep(time2);
	movebase(-speed/6);
	sleep(100);
	movebase(0);


}
void straighten(int speed)
{

	while (SensorValue(gyro)>0)
	{
		setMotor(rightback,speed);
		setMotor(rightfront,speed);
		setMotor(leftback,-speed);
		setMotor(leftfront,-speed);
	}
	while(SensorValue(gyro)<0)
	{
		setMotor(rightback,-speed);
		setMotor(rightfront,-speed);
		setMotor(leftback,speed);
		setMotor(leftfront,speed);
	}

}
void encodrturnleft(int left, int speed,int slwspd)
{
	resetSensor(quadencoder1);
	while(SensorValue(quadencoder1)>-left)
	{
		setMotor(rightback,speed);
		setMotor(rightfront,speed);
		setMotor(leftback,-speed);
		setMotor(leftfront,-speed);
	}
	while(SensorValue(quadencoder1)>-left/6)
		setMotor(rightback,-7);
	setMotor(rightfront,-7);
	setMotor(leftback,7);
	setMotor(leftfront,7);
	sleep(20);
}
void timerturn(int left,int speed)
{

	setMotor(rightback,speed);
	setMotor(rightfront,speed);
	setMotor(leftback,-speed);
	setMotor(leftfront,-speed);
	sleep(left);
	setMotor(rightback,0);
	setMotor(rightfront,0);
	setMotor(leftback,0);
	setMotor(leftfront,0);


}
void ramballmk2(float rollerspd, float fwdspd, int downtime,int rollertime,int uptime,int revtime)
{
	setMotor(arm,-105);
	//	setMotor(arm2,-105);
	sleep(downtime);
	movebase(-fwdspd+15);
	setMotor(intake,-rollerspd);
	setMotor(intake2,-rollerspd);
	sleep(revtime);
	setMotor(arm,40);
	//	setMotor(arm2,40);
	movebase(fwdspd);
	setMotor(arm,0);
	//	setMotor(arm2,0);
	setMotor(intake,-rollerspd);
	setMotor(intake2,-rollerspd);
	sleep(rollertime);
	movebase(-fwdspd);
	setMotor(intake,-rollerspd);
	setMotor(intake2,-rollerspd);
	sleep(revtime);
	setMotor(intake,-rollerspd);
	setMotor(intake2,-rollerspd);
	sleep(rollertime);
	movebase(0);
	setMotor(arm,85);
	//	setMotor(arm2,85);
	sleep(uptime);
	stopAllMotors();
}

void rollerflipmk2(float roll, float roll2,float speed,int rollspd)
{

	{
		clearTimer(T4);
		while(time1[T4]<=roll)
		{
			roller(roll,speed/1.4);
			movebase(speed);

		}
		while(time1[T4]<=roll2)
		{

			roller(roll2,-rollspd);
			movebase(speed/8);
			sleep(roll2);
			break;

		}
		stopAllMotors();
	}


}

void movearm(int time,int speed)
{
	setMotor(arm,speed);
	//setMotor(arm2,speed);
	sleep(time);
	setMotor(arm,-7);
	//	setMotor(arm2,-7);
	sleep(20);
	setMotor(arm,0);
	//setMotor(arm2,0);
}
void programmingskillmk2()
{
	//	fwd(430,30);
	//	ramballmk2(-90,40,880,500,650,600);
	//resetmk2(0,850,60);
	//	fwd(100,60);
	//	advTurnleft(96,20,60);
	//	fwd(490,40);
	//	advturnRight(88.6,40,60);
	//	resetmk2(0,700,55);
	Pidbasecontrol(56,0,1,127);//move fwd 12 inches with 0.25 sec delay
	// fwd(780,90);
	//	rollerflipmk2(660,210,40,90);
	roller(400,-100);
	resetmk2(0,210,80);

	advTurnleft(94,20,60);
	resetmk2(0,700,60);
	//advRev(100,5,60);
	fwd(90,60);
	//advturnRight(8,10,60);
	timerturn(65,-65);
	fwd(150,70);
	roller(1700,-120);
	shoot(1300,105);
	//	resetmk2(0,300,80);
	timerturn(98,60);
	wait(0.5);
	resetmk2(0,930,-80);
	wait(0.4);
	resetmk2(0,520,60);
	turnrightmk2(570,70);

	resetmk2(0,860,100);
	wait(0.2);
	fwd(670,60);
	linespotter(50);

	resetmk2(0,700,60);
	wait(0.4);
	//	advturnleft(85,30,60);
	turnleftmk2(590,60);
	resetmk2(0,800,-90);
	resetmk2(0,680,90);
	advturnRight(90,30,70);
	//	fwd(790,70);

	//fwd(1200,60);
	rollerflipmk4(2800,1300,-110);
	wait(0.25);
	resetmk2(0,250,50);
	wait(0,2);
	timerturn(490,60);
	wait(0.3);
	//fwd(730,60);
	resetmk2(0,1000,-60);
	resetmk2(0,960,70);
	wait(0.3);

	//	advTurnright(85,30,60);
	resetmk2(0,200,60);
	wait(0.2);
	advturnRight(85,30,60);
	//	resetmk2(0,760,100);
	//	wait(0.2);
	resetmk2(0,1400,-70);
	resetmk2(0,200,70);
	wait(0.2);
	//	resetmk2(0,1400,-60);
	wait(0.2);
	//resetmk2(0,3600,60);
	advTurnleft(83,30,60);
	resetmk2(0,560,60);
	wait(0.2);
	turnrightmk2(530,60);
	resetmk2(0,400,-70);
	resetmk2(0,700,60);
	resetmk2(0,1250,127);
	wait(0.6);
	resetmk2(0,900,127);
	jam(30,40);
	stopAllMotors();






	//advFwdmk1(25,25,70);
	//advRev(50,20,80);
	//advturnRight(120,20,80);
	//Pidbasecontrol(31.5,0.01,1,127);
	//rollerflip(300,60,100,800);
	//advFwdmk1(15,20,80);
	//advRev(20,20,80);
	//advTurnleft(90,20,80);
	//advFwdmk1(70,20,80);
	//advRev(200,20,80);
	//advturnRight(90,20,80);
	//advFwdmk1(300,20,80);
	//Pidbasecontrol(50,0.01,1,127);
	//advturnRight(90,20,80);
	//reset(400,50,0);
	//advFwdmk1(150,5,80);
	//jam(0.06,40);q

}
void programmingskillmk1()
{
	Pidbasecontrol(50,0,1,100);//move fwd 12 inches with 0.25 sec delay
	// fwd(780,90);
	rollerflip(420,00,40,90);
	roller(200,60);
	//advRev(100,5,60);
	resetmk2(0,1850,55);
	wait(0.05);
	//advFwdmk1(5,5,20);
	fwd(26,55);
	advTurnleft(83,28,80);
	//turnleftmk2(690,70);
	resetmk2(0,1190,58);
	//turnleftmk2(646,70);
	wait(1);
	Pidbasecontrol(93.5,0,1,100);
	roller(200,-90);
	//turnleftmk2(20,40);
	//turnleftmk2(34,42);
	timerturn(130,80);//this is the bone
	roller(200,70);
	shoot(1100,120);
	fwd(120,70);
	roller(960,-127);
	shoot(1290,127);
	resetmk2(0,380,75);
	wait(0.4);
	//encodrturnleft(100,60,10);
	//turnleftmk2(20,80);
	timerturn(60,54);//this is the one
	fwd(860,70);
	wait(0.7);
	timerturn(45,45);
	//	straighten(35);
	resetmk2(0,955,65);

	//turnrightmk2(580,70);
	roller(500,100);
	wait(0.7);
	//	resetmk2(0,900,70);
	//	fwd(195,70);
	//	rollerflipmk3(60,-100,50,50,0);

	//	resetmk2(0,900,70);



	advturnRight(95,30,60);

	resetmk2(0,1000,60);
	//sleep(900);
	//	ramballmk2(-90,50,800,600,550,600);
	//rollerflip(0,600,40,-90);
	//advFwdmk1(5,20,100);
	//	advRev(10,20,80);
	//advturnRight(90,20,80);
	//	Pidbasecontrol(22,0,100,127);
	//	ramball(300,100,600);
	//	advRev(5,10,60);
	//	grabundercap(200,80,600);
	//	advRev(3,10,60);
	//	advturnRight(90,20,80);
	//	ramball(300,90,800);
	//	advTurnleft(90,20,80);
	//	advFwdmk1(7,10,80);
	///	advTurnleft(90,20,80);
	//	reset(100,80,0);
}

// this is the comp skills not the two on top which was for Macau, no time to fine tune that
void programmingskillmk2short()
{
	Pidbasecontrol(44,0,1,107);//move fwd 12 inches with 0.25 sec delay
	//fwd(100,120);
	rollerflipmk2(490,650,70,120);
	roller(900,-100);
	//advRev(100,5,60);
	resetmk2(0,2250,62);
	roller(400,-100);
	wait(0.05);
	//advFwdmk1(5,5,20);
	fwd(92,55);
	advTurnleft(74,28,80);
	//turnleftmk2(690,70);
	resetmk2(0,1190,58);
	//turnleftmk2(646,70);
	wait(1);
	Pidbasecontrol(92.8,0,1,100);
	roller(200,-0);
	//turnleftmk2(20,40);
	//turnleftmk2(34,42);
	timerturn(15,30);
	roller(100,-80);
	shoot(1100,120);
	fwd(160,70);
	roller(1400,-127);
	shoot(1290,127);
	resetmk2(0,300,75);
	wait(0.4);
	//encodrturnleft(100,60,10);
	//turnleftmk2(20,80);
	timerturn(90,54);//this is the one
	fwd(730,70);
	wait(0.7);
	timerturn(25,25);
	//	straighten(35);
	resetmk2(0,545,65);
	//turnrightmk2(580,70);
	roller(500,100);
	wait(0.7);
	advturnRight(98,30,60);

	resetmk2(0,900,60);
	fwd(220,60);
	rollerflipmk2 (0,660,40,-100);
	resetmk2(0,1500,60);
	fwd(90,60);
	advturnRight(95,20,60);
	Pidbasecontrol(24,1,1,70);
	advTurnleft(98,20,60);
	resetmk2(0,600,90);
		Pidbasecontrol(57.7,0,1,127);//move fwd 12 inches with 0.25 sec delay
	// fwd(780,90);
	//	rollerflipmk2(660,210,40,90);
	roller(400,-100);
	resetmk2(0,210,80);

	advTurnleft(94,20,60);
	resetmk2(0,700,60);
	//advRev(100,5,60);
	fwd(90,60);
	//advturnRight(8,10,60);
	timerturn(105,-75);
	roller(1900,-120);
	fwd(193,70);

	shoot(1300,105);
	//	resetmk2(0,300,80);

  resetmk2(0,1100,60);
  fwd(60,60);
  advturnRight(99,30,60);
  resetmk2(0,	1600,60);
  fwd(80,60);
  advturnRight(95,30,60);
  Pidbasecontrol(21,0,1,90);
  advturnRight(95,20,60);
  resetmk2(0,600,-80);
  resetmk2(0,600,60);
	resetmk2(0,1820,127);
	resetmk2(0,200,60);

}

void autonredmk1()
{
	Pidbasecontrol(42.2,1,1,70);
	roller(780,-107);
	resetmk2(0,1500,60);

	fwd(76.9,50);
	advTurnleft(97,20,70);
	fwd(240,60);
	timerturn(-15,40);
	// roller(700,-100);
	//roller(300,100);
	shoot(1100,100);
	//	advTurnleft(10,10,70);
	fwd(185,60);
	roller(1400,-127);
	shoot(1100,100);
	//	resetmk2(0,420,70);
	//timerturn(36,50);
	resetmk2(0,150,50);
	//	turnleftmk2(40,56);
	//fwd(500,60);
	timerturn(90,65);
	resetmk2(0,1260,-60);
	resetmk2(0,650,60);
	turnrightmk2(580,60);
	resetmk2(0,600,70);
	fwd(188,90);

	rollerflipmk2(00,540,40,110);
	resetmk2(0,400,60);



}
void  autonredmk2()
{

	Pidbasecontrol(41,0,1,127);
	roller(750,-110);
	resetmk2(0,1400,70);
	fwd(100,60);
	advTurnleft(98,30,60);
	wait(2);
	fwd(590,70);
	advTurnleft(95,30,60);
	resetmk2(0,900,-60);
	//	movearm(870,85);
	resetmk2(0,900,60);
	wait(0.25);
	resetmk2(0,1800,127);

}
void autonbluemk1()
{
	Pidbasecontrol(43,0,1,70);
	roller(1000,-110);
	resetmk2(0,1700,60);

	fwd(90,50);
	advturnRight(96,20,70);
	fwd(100,60);
	timerturn(12,40);
	roller(400,-90);
	roller(200,90);
	shoot(1400,127);
	//	advTurnleft(10,10,70);
	fwd(170,60);
	roller(1300,-127);
	shoot(1400,120);
	//	resetmk2(0,420,70);
	//timerturn(36,50);
	resetmk2(0,150,50);
	turnrightmk2(13,36);
	//fwd(500,60);
	resetmk2(0,840,-60);
	resetmk2(0,700,60);
	turnleftmk2(580,60);
	resetmk2(0,600,70);
	fwd(150,90);
	rollerflipmk2(00,510,79,100);
	resetmk2(0,400,60);

}
void autonbluemk2()
{
	Pidbasecontrol(42.5,0,1,127);
	roller(700,-110);
	resetmk2(0,1400,70);
	fwd(100,60);
	advturnRight(98,30,60);
	wait(2);
	fwd(400,70);
	advturnRight(95,30,60);
	resetmk2(0,900,-60);
	//	movearm(870,85);
	resetmk2(0,700,60);
	wait(0.55);
	resetmk2(0,1230,127);

}
void programswitch()
{
	if (SensorValue(potentialmeter)<1000)
	{
		autonbluemk1();
	}
	else if (SensorValue(potentialmeter)<2000)
	{
		autonbluemk2();
	}
	else if(SensorValue(potentialmeter)<3000)
	{
		autonredmk1();
	}
	else if(SensorValue(potentialmeter)>3000)
	{
		autonredmk2();
	}

}
/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{

	SensorType[in8]=sensorNone;
	wait1Msec(1000);
	SensorType[in8]=sensorGyro;
	wait1Msec(1000);
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	//programmingskillmk1();
	//programmingskillmk2();

	// programswitch();//for 15 sec
	programmingskillmk2short();

}
/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
	// User control code here, inside the loop

	while (true)
	{

		motor[leftback]=vexRT[Ch3];
		motor[leftfront]=vexRT[Ch3];
		motor[rightback]=vexRT[Ch2];
		motor[rightfront]=vexRT[Ch2];

		motor[cat]=vexRT[Btn6U]*127;
		motor[cat2]=vexRT[Btn6U]*-127;
		motor[cat3]=vexRT[Btn6U]*127;
		motor[intake]=vexRT[Ch2Xmtr2]*0.88;
		motor[intake2]=vexRT[Ch2Xmtr2]*0.88;
		motor[arm]=vexRT[Ch3Xmtr2]*-1;
		//motor[intake]=vexRT[Btn6UXmtr2]*0.75;
		//motor[intake2]=vexRT[Btn6UXmtr2]*0.75;
		//motor[intake]=vexRT[Btn6UXmtr2]*-0.75;
		//motor[intake2]=vexRT[Btn6UXmtr2]*-0.75;
		//	motor[cat]=vexRT[Btn6D]*-127;
		//motor[cat2]=vexRT[Btn6D]*127;
		//motor[cat3]=vexRT[Btn6D]*-127
		//	motor[arm2]=vexRT[Ch3Xmtr2]*-1;


	}

}
//end
